<PAGE>
	<INCLUDE file="inc/header.tmpl" />

	<VAR match="VAR_SEL_PROTOCOLS" replace="selected" />
	<VAR match="VAR_SEL_GLOBALPROTECT" replace="selected" />
	<PARSE file="menu1.xml" />
	<PARSE file="menu2-protocols.xml" />

	<INCLUDE file="inc/content.tmpl" />

<h1>Palo Alto Networks (PAN) GlobalProtect</h1>

<h2>How the VPN works</h2>

<p>This VPN is based on HTTPS and <a
href="https://tools.ietf.org/html/rfc3948">ESP</a>, with routing and
configuration information distributed in XML format.</p>

<p>GlobalProtect mode is requested by adding <tt>--protocol=gp</tt>
to the command line:
<pre>
  openconnect --protocol=gp vpn.example.com
</pre></p>

<h3>GlobalProtect portals and gateways</h3>

<p>GlobalProtect VPNs actually contain two different server
interfaces: portals and gateways. Most VPNs have one portal server and
one or more gateway servers; the server hosting the portal interface
often hosts a gateway interface as well, but not always. The portal
interface mostly sends centrally-imposed security/lockdown settings
for the official client software to follow. The only information sent
by the portal that's clearly useful to a VPN client like OpenConnect
(which tries to give full control to the end user) is the list of
gateways.</p>

<p>Some GlobalProtect VPNs are configured in such a way that the
client <i>must</i> authenticate to the portal before it can access the
gateway, while with other VPNs no interaction with the portal is
necessary.  In order to replicate the behavior of the official
clients, OpenConnect first attempts to connect to the portal interface
of the specified server.</p>

<ul>
  <li>If <tt>--usergroup=gateway</tt> is specified (or, equivalently,
  <tt>/gateway</tt> is appended to the server URL, e.g.
  <tt>https://vpn.company.com/gateway</tt>), then OpenConnect will
  attempt to skip the portal interface and connect immediately to the
  gateway interface. This is useful if the GlobalProtect VPN portal is
  misconfigured, such as by not offering the desired gateway server in
  the list it provides.</li>
  <li>If connecting to the portal interface yields a choice of
  multiple gateways, <tt>--authgroup=GatewayName</tt> tells OpenConnect
  which one to choose.</li>
</ul>

<h3>Authentication</h3>

<p>To authenticate, you connect to the secure web server (<tt>POST
/ssl-vpn/login.esp</tt>), provide a username, password, and (optionally) a
certificate, and receive an authcookie.  The username, authcookie, and a
couple other bits of information obtained at login are combined into the
OpenConnect cookie.</p>

<h4>SAML multi-factor authentication</h4>

<p>Some servers are configured to authenticate through SAML for
multi-factor authentication. Support for this is provided on the
command line and in combination with network-manager-openconnect.</p>

<p>SAML authentication may be aided by such helpers as <a
href="https://github.com/dlenski/gp-saml-gui">gp-saml-gui</a>, which
is particularly handy at using URLs to produce SAML cookie values and
might be a good choice to use instead of a regular browser when
working with openconnect from the command line, or <a
href="https://github.com/zdave/openconnect-gp-okta">openconnect-gp-okta</a>.</p>

<p>Authenticating with SAML from the command line involves using an
URL, which openconnect displays, to get a cookie.  This generally
involves giving the URL to a web browser, which will ask for username
and then other authentication secrets.  The cookie you need to give to
openconnect to authenticate will always be in the final HTTP response.
Although cookies are passed in HTTP headers, the cookie you need may
often be obtained by looking at the HTML source of the final HTTP
response.</p>

<p>So SAML authentication from the command line happens in multiple
steps.  Openconnect is invoked to give your username to the VPN
portal, which produces an URL.  Then the URL is used to obtain a
cookie.  This cookie has a name.  Known possibilities for the name
are <tt>portal-userauthcookie</tt> and <tt>prelogin-cookie</tt>, but
the actual name should be clear from final SAML authentication HTTP
response, the one that delivers the cookie.</p>

<p>Once the SAML cookie is obtained, openconnect is invoked a second
time to create the VPN connection.  This second invocation of
openconnect must be given the name of the cookie and the cookie's
value.  The name of the cookie can be given in the URL used to connect
to the VPN server endpoint, but it is more clear to use the
<tt>--usergroup</tt> argument, for example, as follows:
<tt>--usergroup=:prelogin-cookie</tt> (As noted above,
<tt>--usergroup</tt> may also specify a "gateway", in which case the
gateway host is given before the colon.)  The cookie's value is best
supplied by using <tt>--passwd-on-stdin</tt>, and pasting when
openconnect pauses (without any textual prompt) and waits for the
authentication secret, followed by a press of the "Enter" key.  (This
keeps the cookie, a secret that grants access, from being recorded in
the shell's command history!)</p>

<p>The GlobalProtect VPN server may be configured so that both the
portal and the gateway require SAML authentication.  In this case the
second openconnect invocation uses the supplied SAML cookie to
authenticate against the portal, but SAML authentication must occur a
second time to obtain a new cookie to authenticate with the gateway.
In this case, after using the first cookie to authenticate with the
portal, the second openconnect invocation displays a new URL and
pauses with a prompt.  This prompt consists of the name of the cookie
(likely <tt>prelogin-cookie</tt>).  Use the new URL to obtain a second
cookie, paste the new cookie at the prompt, and press enter.  The VPN
should then be created.</p>

<h3>Tunnel configuration</h3>

<p>To connect to the secure tunnel, the cookie is used to read routing and
tunnel configuration information (<tt>POST /ssl-vpn/getconfig.esp</tt>).</p>

<p>Next, a <a href="hip.html">HIP report</a> (security scanner report) is
generated by the client and submitted to the server, if required.</p>

<p>Finally, either an HTTPS-based or ESP-based tunnel is setup:</p>

<ol>
  <li>The cookie is used in a non-standard HTTP request (<tt>GET
      /ssl-tunnel-connect.sslvpn</tt>, which acts more like a
      <tt>CONNECT</tt>).  Arbitrary IP packets can be passed over the
      resulting tunnel.</li>
  <li>The ESP keys provided by the configuration request are used to set up
      a <a href="https://tools.ietf.org/html/rfc3948">UDP-encapsulated
      ESP</a> tunnel.</li>
</ol>

<p>Since <a href="https://web.archive.org/web/20230228035749/https://sites.inka.de/~W1011/devel/tcp-tcp.html">TCP over
TCP is very suboptimal</a>, OpenConnect tries to always use ESP-over-UDP,
and will only fall over to the HTTPS tunnel if that fails, or if disabled
via the <tt>--no-dtls</tt> argument.</p>

<h2>Quirks and issues</h2>

<p>There appears to be no reasonable mechanism to negotiate the <a
href="https://en.wikipedia.org/wiki/Maximum_transmission_unit">MTU</a> for
the link, or discover the MTU of the accessed network.  The configuration
always shows <tt><![CDATA[&lt;mtu&gt;0&lt;/mtu&gt;]]></tt>.  OpenConnect attempts to
calculate the MTU by starting from the base MTU with the overhead of
encapsulating each packets within ESP, UDP, and IP.</p>

<p>IPv6 support was added in <a
href="https://live.paloaltonetworks.com/t5/Colossal-Event-Blog/New-GlobalProtect-4-0-announced-with-IPv6-support/ba-p/141593">GlobalProtect
4.0 in 2017</a>. OpenConnect has experimental support for GlobalProtect IPv6 as of
9.0. If you have access to a GlobalProtect VPN that supports IPv6, please send
feedback to <a href="mail.html">the mailing list</a>.</p>

<p>The ESP and HTTPS tunnels cannot be connected simultaneously.  The ESP
tunnel becomes unresponsive as soon as the HTTPS tunnel is started, and
remains so unless/until the tunnel is closed and the configuration is
re-fetched.</p>

<p>Compared to the AnyConnect or Juniper protocols, the GlobalProtect
protocol appears to have very little in the way of <a
href="https://en.wikipedia.org/wiki/In-band_signaling">in-band
signaling</a>.  The HTTPS tunnel can only send or receive IP packets and a
simple DPD/keepalive packet (always sent by the client and echoed by the
server).  The ESP tunnel does not have any special DPD/keepalive packet, but
uses an <a
href="https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol">ICMP</a>
("ping") request to the server with a magic payload for this purpose</p>

	<INCLUDE file="inc/footer.tmpl" />
</PAGE>
